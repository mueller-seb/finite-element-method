# finite-element-method
Finite element code in matlab for two different boundary value problems:

>BVP #1  
>-laplace(u) = sin(pi*x)*sin(pi*y) in Omega  
>u = 0 on boundary of Omega (Dirichlet cond.)  
>Omega = [0,1]^2

>BVP #2  
>-laplace(u)+u = cos(pi*x)*cos(pi*y) in Omega  
>partial_n(u) = 0 on boundary of Omega (Neumann cond.)  
>Omega = [0,1]^2  
>Further math. description in Num. treatment of PDE, Grossmann & Roos, Remark 3.27

The program applies FEM on both BVPs on a mesh of squares, rectangular triangles or arbitrary triangles.
Intervals of both the rectangular meshes and a discrete solution matrix are freely selectable. Polynomials of the ansatz function space can be determined to be of different degrees (see annotations). The discrete solution is plotted and the L2 error ||u-u_h||_Omega (anlytical solution is known) and the a posteriori error estimator eta (Num. treatment of PDEs, Grossmann & Roos, p. 290) are calculated. The L2 error converges for increasingly finer meshes.

## HowTo
Make sure, that all files are in the same folder. Choose all parameters in the upper section of main.m and run main.m.

## Annotations
A self-implemented PCG solver is used to solve the linear equation system A_h * u_h = f_h.
Self-implemented Gauss quadrature is used to calculate all integrals over domains and edges.
For the arbitrary triangles, the Matlab PDE Toolbox is used to generate mesh data (points and elements) fitting on our classes. In arbTriangles_PDE.m you can choose whether to load mesh data from a file generated by the Toolbox or to generate it by yourself by setting the constant. This arbitrary mesh is also plotted.

Computing with polynomials of higher degrees "attaches" additional fix points to the mid of each edge before determining the coefficients of shape polynomials.

### Efficiency
The code is slightly enlarged due to some functions that improve the efficiency of the algorithm:  

Discrete evaluation of the approx. solution is optimized in terms of choosing the related domain for each evaluation point. Instead of summing up ALL evaluated basis functions weighted by u_h, only bassis functions including shape functions defined on that domain are regarded (the method isn't easily adaptable to arbitrary meshes of course).
Therefore the solution class has an array property "shapeScalarFunctions" that assigns a shape scalar function to its corresponding domain of the mesh. This is also used to increase efficiency of the L2 error calculation and a posteriori estimation.
Dicrete evaluation is extremely simple if evaluation points and mesh nodes coincide (solutionOnMeshPoints).

To achieve better performance calculating the stiffness matrix A_h, a space of gradients of all basis functions of the ansatz function space is computed in advance. This avoids multiple computations of the same gradients.
Additionally, calculation of a(phi_i, phi_j) is restricted to integration over the common domains of both basis functions.
In the case of rectangular triangles or squares, integration is only executed if basis nodes are neighbours.